// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "linux-musl-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// NextAuth.js Models
model User {
  id            String    @id @default(cuid())
  email         String    @unique
  name          String?
  image         String?
  emailVerified DateTime?
  
  // User preferences
  cacheAllEnabled Boolean @default(false)  // Global cache-all setting (cross-device)
  
  // Multi-region support
  homeRegion    String    @default("default")  // "jp", "sea", "usw", or "default" for AIO
  
  accounts      Account[]
  sessions      Session[]
  libraries     Library[]
  playlists     Playlist[]
  playbackPreference PlaybackPreference?
  playbackProgress   PlaybackProgress?
  
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  
  @@map("users")
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map("accounts")
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@map("sessions")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
  @@map("verification_tokens")
}

// ============================================
// M3W Music Player Models
// ============================================

// Physical file storage (deduplicated by hash)
model File {
  id          String   @id @default(cuid())
  hash        String   @unique  // SHA256 hash of file content
  path        String   // MinIO path: /files/{hash}.mp3
  size        Int      // File size in bytes
  mimeType    String   // audio/mpeg, audio/flac, etc.
  
  // Audio physical properties (extracted once)
  duration    Int?     // Duration in seconds
  bitrate     Int?     // Bitrate in kbps
  sampleRate  Int?     // Sample rate in Hz
  channels    Int?     // Number of audio channels
  
  // Reference counting for garbage collection
  refCount    Int      @default(0)
  
  songs       Song[]
  
  createdAt   DateTime @default(now())
  
  @@index([hash])
  @@map("files")
}

// Music Library (user's collection)
model Library {
  id          String   @id @default(cuid())
  name        String
  description String?
  
  // Cached count for fast access (updated on add/delete)
  songCount   Int      @default(0)
  
  // Default Library flags (for frontend refactor)
  isDefault   Boolean  @default(false)  // Mark default library (auto-created)
  canDelete   Boolean  @default(true)   // Prevent deletion of default library
  
  // Offline cache policy: 'inherit' | 'always' | 'never'
  cacheOverride String @default("inherit")
  
  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  songs       Song[]
  playAllPlaylist Playlist? @relation("LibraryPlayAllPlaylist")
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@index([userId])
  @@index([userId, isDefault])
  @@map("libraries")
}

// Song (user-specific metadata + file reference)
model Song {
  id          String   @id @default(cuid())
  
  // User-editable metadata
  title       String
  artist      String?
  album       String?
  albumArtist String?
  year        Int?
  genre       String?
  trackNumber Int?
  discNumber  Int?
  composer    String?
  
  // File reference (deduplication)
  fileId      String
  file        File     @relation(fields: [fileId], references: [id], onDelete: Restrict)
  
  // Cover art (may differ per user)
  coverUrl    String?
  
  // Library ownership
  libraryId   String
  library     Library  @relation(fields: [libraryId], references: [id], onDelete: Cascade)
  
  // Raw metadata from file (JSON blob for flexibility)
  rawMetadata Json?
  
  lyrics      Lyrics[]
  playlistSongs PlaylistSong[]
  playbackProgressRecords PlaybackProgress[] @relation("SongPlaybackProgress")
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@index([libraryId])
  @@index([fileId])
  @@map("songs")
}

// Lyrics (multiple sources per song)
model Lyrics {
  id       String @id @default(cuid())
  
  songId   String
  song     Song   @relation(fields: [songId], references: [id], onDelete: Cascade)
  
  content  String @db.Text
  source   String // "netease" | "qq" | "spotify" | "manual" | "lrc_file"
  language String @default("zh-CN")
  
  createdAt DateTime @default(now())
  
  @@unique([songId, source])
  @@index([songId])
  @@map("lyrics")
}

// Playlist (combines songs from multiple libraries)
model Playlist {
  id          String   @id @default(cuid())
  name        String
  description String?
  coverUrl    String?
  
  // Cached count for fast access (updated on add/remove)
  songCount   Int      @default(0)
  
  // Flags for default playlist behavior
  isDefault   Boolean  @default(false)   // Mark favorites playlist (auto-created)
  canDelete   Boolean  @default(true)    // Prevent deletion of default playlist
  
  // Link to library for "Play All" generated playlists
  linkedLibraryId String? @unique
  linkedLibrary   Library? @relation("LibraryPlayAllPlaylist", fields: [linkedLibraryId], references: [id], onDelete: Cascade)
  
  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Song relationships via junction table (order maintained by PlaylistSong.order)
  songs       PlaylistSong[]
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@index([userId])
  @@index([userId, isDefault])
  @@map("playlists")
}

// Playlist-Song relationship (with ordering)
model PlaylistSong {
  playlistId String
  playlist   Playlist @relation(fields: [playlistId], references: [id], onDelete: Cascade)
  
  songId     String
  song       Song     @relation(fields: [songId], references: [id], onDelete: Cascade)
  
  order      Int      @default(0)
  addedAt    DateTime @default(now())
  
  @@id([playlistId, songId])
  @@index([playlistId, order])
  @@map("playlist_songs")
}

model PlaybackPreference {
  userId          String   @id
  shuffleEnabled  Boolean  @default(false)
  repeatMode      String   @default("off")
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("playback_preferences")
}

model PlaybackProgress {
  userId       String   @id
  songId       String
  position     Int      @default(0)
  contextType  String?
  contextId    String?
  contextName  String?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  song Song @relation("SongPlaybackProgress", fields: [songId], references: [id], onDelete: Cascade)

  @@index([songId])
  @@map("playback_progress")
}
