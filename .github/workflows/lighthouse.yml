name: Lighthouse CI

on:
  # Run on releases (after deploy to demo site)
  release:
    types: [published]
  # Allow manual trigger
  workflow_dispatch:
    inputs:
      url:
        description: 'URL to audit'
        required: false
        default: 'https://m3w.test3207.top'

permissions:
  contents: write

jobs:
  lighthouse:
    name: Lighthouse Audit
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event_name == 'release' && github.event.release.tag_name || 'main' }}
      
      - name: Run Lighthouse CI
        id: lighthouse
        uses: treosh/lighthouse-ci-action@v12
        with:
          urls: |
            ${{ github.event.inputs.url || 'https://m3w.test3207.top' }}
          uploadArtifacts: true
          temporaryPublicStorage: true
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '25.2.1'
      
      - name: Generate Lighthouse badges
        run: |
          # Create output directory
          mkdir -p assets/lighthouse
          
          # Generate badges from manifest
          MANIFEST_PATH="${{ steps.lighthouse.outputs.manifest }}"
          echo "Manifest path: $MANIFEST_PATH"
          
          # Parse scores from manifest and generate badges
          node << 'EOF'
          const fs = require('fs');
          
          // Helper function to extract scores from report
          function getScores(report) {
            return {
              performance: Math.round(report.categories.performance.score * 100),
              accessibility: Math.round(report.categories.accessibility.score * 100),
              'best-practices': Math.round(report.categories['best-practices'].score * 100),
              seo: Math.round(report.categories.seo.score * 100),
              pwa: Math.round((report.categories.pwa?.score || 0) * 100)
            };
          }
          
          // Read manifest
          const manifestPath = (process.env.MANIFEST_PATH && process.env.MANIFEST_PATH.trim()) || '.lighthouseci/manifest.json';
          let manifest;
          try {
            manifest = JSON.parse(fs.readFileSync(manifestPath, 'utf8'));
          } catch (e) {
            // Try alternative path if manifest file is not readable
            let files = [];
            try {
              if (fs.existsSync('.lighthouseci')) {
                files = fs
                  .readdirSync('.lighthouseci')
                  .filter(f => f.endsWith('.json') && f !== 'manifest.json');
              }
            } catch (dirErr) {
              // Ignore and handle as "no results"
            }
            
            if (files.length > 0) {
              manifest = [{ summary: '.lighthouseci/' + files[0] }];
            } else {
              console.error('No lighthouse results found');
              process.exit(1);
            }
          }
          
          // Get the first result
          const result = Array.isArray(manifest) ? manifest[0] : manifest;
          const summaryPath = result.summary || result.jsonPath;
          
          let scores;
          if (summaryPath && fs.existsSync(summaryPath)) {
            const report = JSON.parse(fs.readFileSync(summaryPath, 'utf8'));
            scores = getScores(report);
          } else {
            // Try to find lhr file
            if (fs.existsSync('.lighthouseci')) {
              const lhrFiles = fs.readdirSync('.lighthouseci').filter(f => f.startsWith('lhr-') && f.endsWith('.json'));
              if (lhrFiles.length > 0) {
                const report = JSON.parse(fs.readFileSync('.lighthouseci/' + lhrFiles[0], 'utf8'));
                scores = getScores(report);
              }
            }
          }
          
          if (!scores) {
            console.error('Could not extract scores');
            process.exit(1);
          }
          
          console.log('Scores:', scores);
          
          // Color based on score
          function getColor(score) {
            if (score >= 90) return 'brightgreen';
            if (score >= 50) return 'orange';
            return 'red';
          }
          
          // Generate badge URLs for shields.io
          const badges = {};
          for (const [key, score] of Object.entries(scores)) {
            const label = key
              .split('-')
              .map(part => part.charAt(0).toUpperCase() + part.slice(1))
              .join(' ');
            const color = getColor(score);
            badges[key] = `https://img.shields.io/badge/${encodeURIComponent(label)}-${score}%25-${color}`;
          }
          
          // Save scores JSON for README generation
          fs.writeFileSync('assets/lighthouse/scores.json', JSON.stringify({ scores, badges, timestamp: new Date().toISOString() }, null, 2));
          console.log('Scores saved to assets/lighthouse/scores.json');
          
          // Update README badges
          function updateReadme(filePath) {
            let content = fs.readFileSync(filePath, 'utf8');
            
            // Replace each badge
            content = content.replace(
              /https:\/\/img\.shields\.io\/badge\/Performance-\d+%25-\w+/g,
              badges.performance
            );
            content = content.replace(
              /https:\/\/img\.shields\.io\/badge\/Accessibility-\d+%25-\w+/g,
              badges.accessibility
            );
            content = content.replace(
              /https:\/\/img\.shields\.io\/badge\/Best%20Practices-\d+%25-\w+/g,
              badges['best-practices']
            );
            content = content.replace(
              /https:\/\/img\.shields\.io\/badge\/SEO-\d+%25-\w+/g,
              badges.seo
            );
            if (badges.pwa) {
              content = content.replace(
                /https:\/\/img\.shields\.io\/badge\/PWA-\d+%25-\w+/g,
                badges.pwa
              );
            }
            
            fs.writeFileSync(filePath, content);
            console.log(`Updated ${filePath}`);
          }
          
          updateReadme('README.md');
          updateReadme('README.zh-CN.md');
          EOF
        env:
          MANIFEST_PATH: ${{ steps.lighthouse.outputs.manifest }}
      
      - name: Commit badges
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          # Always commit to main branch (badges should be updated in main)
          git fetch origin main
          git checkout main
          git add assets/lighthouse/ README.md README.zh-CN.md
          git diff --staged --quiet || git commit -m "chore: update lighthouse badges [skip ci]"
          git push origin main
